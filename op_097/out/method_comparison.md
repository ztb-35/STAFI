# 权重选择方法对比分析

生成时间: 2026-02-12 17:00

## 测试配置
- 模块限制: `vision` (61 个权重张量)
- Top-W: 5 个候选权重
- Per-Tensor-K: 每个张量选 1 个权重
- 梯度 Epsilon: 0.001
- 验证批次: 1 batch, 序列长度 5

---

## 方法一：基于梯度 (Gradient-based)

**计算方法**: 数值梯度 `grad ≈ (loss(w + ε) - loss(w)) / ε`

**计算时间**: ~5分42秒 (5.6秒/张量)

### 选中的 Top-5 权重

| 排名 | 层名称 | 权重索引 | 梯度分数 |
|------|--------|----------|----------|
| 1 | `vision.stages.1.downsample.proj.1` | 13029 | **6.736** |
| 2 | `vision.stages.0.blocks.1.token_mixer` | 454 | **6.568** |
| 3 | `vision.stages.1.blocks.1.token_mixer` | 364 | 2.700 |
| 4 | `vision.stages.0.blocks.0.token_mixer` | 211 | 2.286 |
| 5 | `vision.stages.3.downsample.proj.1` | 25650 | 2.116 |

**特点**:
- ✅ 选择对损失函数影响最大的权重
- ✅ 重点关注 **downsample** 和 **token_mixer** 层
- ✅ 更符合模型优化原理

---

## 方法二：基于绝对值 (Magnitude-based)

**计算方法**: 权重绝对值 `|weight|`

**计算时间**: <1秒 (无需前向传播)

### 选中的 Top-5 权重

| 排名 | 层名称 | 权重索引 | 绝对值分数 |
|------|--------|----------|-----------|
| 1 | `vision.stem.2` | 260 | **20.438** |
| 2 | `vision.stages.3.blocks.1.token_mixer` | 94 | 15.313 |
| 3 | `vision.stages.2.blocks.0.token_mixer` | 2119 | 14.883 |
| 4 | `vision.stem.1` | 340 | 14.688 |
| 5 | `vision.final_conv` | 224 | 14.484 |

**特点**:
- ✅ 计算速度快
- ⚠️ 选择数值最大的权重
- ⚠️ 重点关注 **stem** (早期卷积) 和 **final_conv** 层

---

## 关键差异

### 1. **选中的层完全不同**
- **梯度方法**: downsample (下采样层) + token_mixer (注意力机制)
- **绝对值方法**: stem (初始卷积) + final_conv (最终卷积)

### 2. **没有重叠的权重**
- 两种方法选择的 5 个权重**完全不同**
- 说明梯度信息与权重大小不直接相关

### 3. **分数差异**
- 梯度分数范围: 2.1 - 6.7
- 绝对值分数范围: 14.5 - 20.4
- 分数量级和含义完全不同

---

## 推荐使用场景

### 使用梯度方法 (Gradient-based) 当:
- ✅ 想要找到对模型输出影响最大的权重
- ✅ 进行 bit-flip 攻击分析（找最关键的 bit）
- ✅ 研究模型脆弱性和鲁棒性
- ⚠️ 可以接受较长的计算时间

### 使用绝对值方法 (Magnitude-based) 当:
- ✅ 需要快速筛选候选权重
- ✅ 假设大权重对模型更重要
- ✅ 进行初步探索性分析
- ⚠️ 可能错过低值但高影响的权重

---

## 总结

对于 **bit-flip 攻击研究**，推荐使用 **梯度方法**，因为：
1. 直接优化目标：找到对损失函数影响最大的权重
2. 更准确：考虑了权重在模型中的实际作用
3. 更有效：翻转这些权重的 bit 更可能破坏模型性能

绝对值方法可作为快速预筛选工具使用。
